options{
    STATIC = false;
    DEBUG_PARSER = true;
    UNICODE_INPUT = true;
    JDK_VERSION = "1.8";
}

PARSER_BEGIN(Parser)

import net.loveruby.cflat.ast.*;
import net.loveruby.cflat.entity.*;
import net.loveruby.cflat.type.*;
import net.loveruby.cflat.asm.Label;
import net.loveruby.cflat.utils.ErrorHandler;
import net.loveruby.cflat.exception.*;
import java.lang.reflect.*;
import java.util.*;
import java.io.*;

class Parser {

    // 生成语法树，不包含调试信息
    static public AST parserFile(File file, LibraryLoader loader,
                        ErrorHandler errorHandler) throws SyntaxException, FileException {
        return parseFile(file, loader, errorHandler, false);
    }
    // 生成语法树
    static public AST parserFile(File file, LibraryLoader loader,
                        ErrorHandler errorHandler, boolean debug) throws SyntaxException, FileException {
        return new newFileParser(file, loader, errorHandler, debug).parse();
    }
    // 解析 声明的变量和函数，不包含调试信息
    static public Declarations parserDeclFile(File file, LibraryLoader loader,
                        ErrorHandler errorHandler) throws SyntaxException, FileException {
        return parseDeclFile(file, loader, errorHandler, false);
    }
    // 解析 声明的变量和函数
    static public Declarations parserDeclFile(File file, LibraryLoader loader,
                        ErrorHandler errorHandler, boolean debug) throws SyntaxException, FileException {
        return new newDeclFileParser(file, loader, errorHandler, debug).parseDecls();
    }


    // 源文件编码格式，设定为 UTF-8
    static final public String SOURCE_ENCODING = "UTF-8";
    // 读取源文件，生成Parser对象
    static public Parser newFileParser(File file, LibraryLoader loader,
                        ErrorHandler errorHandler, boolean debug) throws FileException {
        try {
            BufferedReader reader = new BufferedReader(
                                            new InputStreamReader(
                                                    new FileInputStream(file), SOURCE_ENCODING));
            return new Parser(reader, file.getPath(), loader, errorHandler, debug);
        }catch (FileNotFoundException ex){
            throw new FileException(ex.getMessage());
        }catch (UnsupportedEncodingException ex){
            throw new Error("UTF-8 is not supported: " + ex.getMessage());
        }
    }

    private String sourceName;
    private LibraryLoader loader;
    private ErrorHandler errorHandler;
    private Set<String> knownTypedefs;  // Typedef 重命名的类型

    // 构造函数 1
    public Parser(Reader reader, String name,
            LoadLibrary loader, ErrorHandler errorHandler){
        this(reader, name, loader, errorHandler);
    }
    // 构造函数 2
    public Parser(Reader reader, String name,
            LoadLibrary loader, ErrorHandler errorHandler, boolean debug){
        this(reader);  // javaCC 有四个默认构造函数，其中一个构造函数是 Parser(Reader reader)
        this.sourceName = name;
        this.loader = loader;
        this.errorHandler = errorHandler;
        this.knownTypedefs = new HashSet<String>();
        // cbc 中参数 --debug-parser 指定 且在 javaCC 的选项中启用 DEBUG_PARSER
        if(debug){
            // javaCC 生成的方法
            enable_tracing();
        }else{
            disable_tracing();
        }
    }

    // 解析源文件生成抽象语法树
    public AST parse() throws SyntaxException {
        try {
            return compilation_unit();
        }catch (TokenMgrError ex){
            throw new SyntaxException(ex.getMessage());
        }catch (ParseException ex){
            throw new SyntaxException(ex.getMessage());
        }catch (LookAheadSuccess err){
            throw new SyntaxException("syntax error");
        }
    }
    // 解析 头文件的声明
    public Declarations parseDecls() throws SyntaxException {
        try {
            return declaration_file();
        }catch (TokenMgrError ex) {
            throw new SyntaxException(ex.getMessage());
        }catch (ParseException ex) {
            throw new SyntaxException(ex.getMessage());
        }
    }

    // 把 Typedef 重命名的类名加入到 knownTypedefs 中， import_stmts()中使用
    private void addKnownTypedefs(List<TypedefNode> typedefs){
        for(TypedefNode typedef : typedefs){
            addType(typedef.name());
        }
    }
    // typedef() 中用到
    private void addType(String name){
        knownTypedefs.add(name);
    }
    // 判断 type_base() 中 <IDENTIFIER>是否是类型名
    public boolean isType(String name){
        return knownTypedefs.contains(name);
    }

    // 把整数 字面量转换成对应的 IntegerLiteralNode 节点，并确定类型
    private IntegerLiteralNode(Location loc, String image){
        long i = integerValue(image);
        if (image.endsWith("UL")) {
            return new IntegerLiteralNode(loc, IntegerTypeRef.ulongRef(), i);
        }
        else if (image.endsWith("L")) {
            return new IntegerLiteralNode(loc, IntegerTypeRef.longRef(), i);
        }
        else if (image.endsWith("U")) {
            return new IntegerLiteralNode(loc, IntegerTypeRef.uintRef(), i);
        }
        else {
            return new IntegerLiteralNode(loc, IntegerTypeRef.intRef(), i);
        }
    }
    // 把 整形字面量 转换成 对应的数字，并区分进制的区别
    private long integerValue(String){
        String s = image.replaceFirst("[UL]+", "");
        if(s.startWith("0x") && s.startWith("0X")){
            return Long.parserLong(s.substring(2), 16);
        }
        else if (s.startsWith("0") && !s.equals("0")) {
            return Long.parseLong(s.substring(1), 8);
        }
        else {
            return Long.parseLong(s, 10);
        }
    }

    // 处理 char 型数据字面量
    private long characterCode(String image) throws ParseException {
        String s = stringValue(image);
        if (s.length() != 1) {
            throw new Error("must not happen: character length > 1");
        }
        return (long)s.charAt(0);
    }

    // 处理 string 字面量
    private String stringValue(String _image) throws ParseException {
        int pos = 0;
        int idx;
        StringBuilder buf = new StringBuilder();
        // 去掉首尾的 双引号
        String image = _image.substring(1, _image.length() - 1);

        // 查找 字面量 中的 转义字符
        while ((idx = image.indexOf("\\", pos)) >= 0) {
            buf.append(image.substring(pos, idx));
            // 类似 \123 这样的八进制 ascii码
            if (image.length() >= idx + 4
                    && Character.isDigit(image.charAt(idx+1))
                    && Character.isDigit(image.charAt(idx+2))
                    && Character.isDigit(image.charAt(idx+3))) {
                    // unescapeOctal 函数 把 八进制字面量 的 十进制int 再转成 char
                buf.append(unescapeOctal(image.substring(idx+1, idx+4)));
                pos = idx + 4;
            }
            else {
                // 处理其余的转义字符
                buf.append(unescapeSeq(image.charAt(idx+1)));
                pos = idx + 2;
            }
        }
        if (pos < image.length()) {
            buf.append(image.substring(pos, image.length()));
        }
        return buf.toString();
    }

    // 用于 SizeofTypeNode, 因为 sizeof 的结果是一个 无符号长整型
    private TypeRef size_t() {
        return IntegerTypeRef.ulongRef();
    }

    // 把 类似 /123 这样的 八进制 ascii码 转换成 十进制
    private static final int charMax = 255;

    private char unescapeOctal(String digits) throws ParseException {
        int i = Integer.parseInt(digits, 8);
        if (i > charMax) {
            throw new ParseException(
                "octal character sequence too big: \\" + digits);
        }
        return (char)i;
    }

    // 处理 其他转移字符
    private static final char bell = 7;
    private static final char backspace = 8;
    private static final char escape = 27;
    private static final char vt = 11;

    private char unescapeSeq(char c) throws ParseException {
        switch (c) {
        case '0': return '\0';
        case '"': return '"';
        case '\'': return '\'';
        case 'a': return bell;
        case 'b': return backspace;
        case 'e': return escape;
        case 'f': return '\f';
        case 'n': return '\n';
        case 'r': return '\r';
        case 't': return '\t';
        case 'v': return vt;
        default:
            throw new ParseException("unknown escape sequence: \"\\" + c);
        }
    }


    // 获取 源文件sourceName 的 token 的位置
    protected Location location(Token t){
        return new Location(sourceName, t);
    }

}

PARSER_END(Parser)

/*
 * 词法分析
 */

// 空白符，换行符等
SPECIAL_TOKEN: { <SPACES: ([" ", "\f", "\t", "\r", "\n"])+> }

// 多行注释
MORE: { <"/*">: IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> MORE: { <~[]> }
<IN_BLOCK_COMMENT> SPECIAL_TOKEN: { <BLOCK_COMMENT: "*/">: DEFAULT }

// 单行注释
SPECIAL_TOKEN: { <LINE_COMMENT: "//" (~["\n", "\r"])* ("\n"|"\r\n"|"\r")?> }

// 关键字
TOKEN: {
      <VOID     : "void">
    | <CHAR     : "char">
    | <SHORT    : "short">
    | <INT      : "int">
    | <LONG     : "long">
    | <STRUCT   : "struct">
    | <UNION    : "union">
    | <ENUM     : "enum">
    | <STATIC   : "static">
    | <EXTERN   : "extern">
    | <CONST    : "const">
    | <SIGNED   : "signed">
    | <UNSIGNED : "unsigned">
    | <IF       : "if">
    | <ELSE     : "else">
    | <SWITCH   : "switch">
    | <CASE     : "case">
    | <DEFAULT_ : "default">
    | <WHILE    : "while">
    | <DO       : "do">
    | <FOR      : "for">
    | <RETURN   : "return">
    | <BREAK    : "break">
    | <CONTINUE : "continue">
    | <GOTO     : "goto">
    | <TYPEDEF  : "typedef">
    | <IMPORT   : "import">
    | <SIZEOF   : "sizeof">
}

// 标识符
TOKEN: {
    <IDENTIFIER: ["A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0"-"9"])* >
}

// 数字
TOKEN: {
    <INTEGER: ["1"-"9"] (["0"-"9"])* ("U")? ("L")?
          | "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+ ("U")? ("L")?
          | "0" (["0"-"7"])* ("U")? ("L")?
          >
}

// 字符
MORE: {"\'": IN_CHARACTER }                         // rule1
<IN_CHARACTER> MORE: {
      <~["'", "\\", "\n", "\r"]> : CHARACTER_TERM      // rule2
    | <"\\" (["0"-"7"]){3}>      : CHARACTER_TERM      // rule3
    | <"\\" ~[]>                 : CHARACTER_TERM      // rule4
}
<CHARACTER_TERM> TOKEN: { <CHARACTER: "'"> : DEFAULT } // rule5}

// 字符串
MORE: { <"\""> : IN_STRING }                           // rule1
<IN_STRING> MORE: {
      <(~["\"", "\\", "\n", "\r"])+>                   // rule2
    | <"\\" (["0"-"7"]){3}>                            // rule3
    | <"\\" ~[]>                                       // rule4
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT }        // rule5


/*
 * 语法分析
 */

// 抽象语法树生成
AST compilation_unit():
{
    Token t;
    Declarations impdecls, decls;
}
{
        {
            t = getToken(1);
        }
    impdecls=import_stmts() decls=top_defs() <EOF>
        {
            decls.add(impdecls);
            return new AST(location(t), decls);
        }
}
// 解析头文件中的声明（ 含有源文件中不能包含 extern ）
Declarations declaration_file():
{
    Declarations impdecls, decls = new Declarations();
    UndefinedFunction funcdecl;
    UndefinedVariable vardecl;
    Constant defconst;
    StructNode defstruct;
    UnionNode defunion;
    TypedefNode typedef;
}
{
    impdecls=import_stmts()
        {
            return decls.add(impdecls);
        }
    ( LOOKAHEAD(<EXTERN> typeref() <IDENTIFIER> "(")
    funcdecl=funcdecl() { decls.addFuncdecl(funcdecl); }
    | vardecl=vardecl() { decls.addVardecl(vardecl); }
    | deconst=defconst() { decls.addConstant(defconst); }
    | defstruct=defstruct() { decls.addDefstruct(defstruct); }
    | defunion=defunion() { decls.addDefunion(defunion); }
    | typedef=typedef() { decls.addTypedef(typedef); }
    )*
    <EOF>
        {
            return decls;
        }
}

